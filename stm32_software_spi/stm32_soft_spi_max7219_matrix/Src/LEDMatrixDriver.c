#include "LEDMatrixDriver.h"

// This is the font definition. You can use http://gurgleapps.com/tools/matrix to create your own font or sprites.
// If you like the font feel free to use it. I created it myself and donate it to the public domain.
uint8_t font[95][8] =
{
  {0,0,0,0,0,0,0,0}, // SPACE
  {0x10,0x18,0x18,0x18,0x18,0x00,0x18,0x18}, // EXCL
  {0x28,0x28,0x08,0x00,0x00,0x00,0x00,0x00}, // QUOT
  {0x00,0x0a,0x7f,0x14,0x28,0xfe,0x50,0x00}, // #
  {0x10,0x38,0x54,0x70,0x1c,0x54,0x38,0x10}, // $
  {0x00,0x60,0x66,0x08,0x10,0x66,0x06,0x00}, // %
  {0,0,0,0,0,0,0,0}, // &
  {0x00,0x10,0x18,0x18,0x08,0x00,0x00,0x00}, // '
  {0x02,0x04,0x08,0x08,0x08,0x08,0x08,0x04}, // (
  {0x40,0x20,0x10,0x10,0x10,0x10,0x10,0x20}, // )
  {0x00,0x10,0x54,0x38,0x10,0x38,0x54,0x10}, // *
  {0x00,0x08,0x08,0x08,0x7f,0x08,0x08,0x08}, // +
  {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x08}, // COMMA
  {0x00,0x00,0x00,0x00,0x7e,0x00,0x00,0x00}, // -
  {0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06}, // DOT
  {0x00,0x04,0x04,0x08,0x10,0x20,0x40,0x40}, // /
  {0x00,0x38,0x44,0x4c,0x54,0x64,0x44,0x38}, // 0
  {0x04,0x0c,0x14,0x24,0x04,0x04,0x04,0x04}, // 1
  {0x00,0x30,0x48,0x04,0x04,0x38,0x40,0x7c}, // 2
  {0x00,0x38,0x04,0x04,0x18,0x04,0x44,0x38}, // 3
  {0x00,0x04,0x0c,0x14,0x24,0x7e,0x04,0x04}, // 4
  {0x00,0x7c,0x40,0x40,0x78,0x04,0x04,0x38}, // 5
  {0x00,0x38,0x40,0x40,0x78,0x44,0x44,0x38}, // 6
  {0x00,0x7c,0x04,0x04,0x08,0x08,0x10,0x10}, // 7
  {0x00,0x3c,0x44,0x44,0x38,0x44,0x44,0x78}, // 8
  {0x00,0x38,0x44,0x44,0x3c,0x04,0x04,0x78}, // 9
  {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00}, // :
  {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x08}, // ;
  {0x00,0x10,0x20,0x40,0x80,0x40,0x20,0x10}, // <
  {0x00,0x00,0x7e,0x00,0x00,0xfc,0x00,0x00}, // =
  {0x00,0x08,0x04,0x02,0x01,0x02,0x04,0x08}, // >
  {0x00,0x38,0x44,0x04,0x08,0x10,0x00,0x10}, // ?
  {0x00,0x30,0x48,0xba,0xba,0x84,0x78,0x00}, // @
  {0x00,0x1c,0x22,0x42,0x42,0x7e,0x42,0x42}, // A
  {0x00,0x78,0x44,0x44,0x78,0x44,0x44,0x7c}, // B
  {0x00,0x3c,0x44,0x40,0x40,0x40,0x44,0x7c}, // C
  {0x00,0x7c,0x42,0x42,0x42,0x42,0x44,0x78}, // D
  {0x00,0x78,0x40,0x40,0x70,0x40,0x40,0x7c}, // E
  {0x00,0x7c,0x40,0x40,0x78,0x40,0x40,0x40}, // F
  {0x00,0x3c,0x40,0x40,0x5c,0x44,0x44,0x78}, // G
  {0x00,0x42,0x42,0x42,0x7e,0x42,0x42,0x42}, // H
  {0x00,0x7c,0x10,0x10,0x10,0x10,0x10,0x7e}, // I
  {0x00,0x7e,0x02,0x02,0x02,0x02,0x04,0x38}, // J
  {0x00,0x44,0x48,0x50,0x60,0x50,0x48,0x44}, // K
  {0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x7c}, // L
  {0x00,0x82,0xc6,0xaa,0x92,0x82,0x82,0x82}, // M
  {0x00,0x42,0x42,0x62,0x52,0x4a,0x46,0x42}, // N
  {0x00,0x3c,0x42,0x42,0x42,0x42,0x44,0x38}, // O
  {0x00,0x78,0x44,0x44,0x48,0x70,0x40,0x40}, // P
  {0x00,0x3c,0x42,0x42,0x52,0x4a,0x44,0x3a}, // Q
  {0x00,0x78,0x44,0x44,0x78,0x50,0x48,0x44}, // R
  {0x00,0x38,0x40,0x40,0x38,0x04,0x04,0x78}, // S
  {0x00,0x7e,0x90,0x10,0x10,0x10,0x10,0x10}, // T
  {0x00,0x42,0x42,0x42,0x42,0x42,0x42,0x3e}, // U
  {0x00,0x42,0x42,0x42,0x42,0x44,0x28,0x10}, // V
  {0x80,0x82,0x82,0x92,0x92,0x92,0x94,0x78}, // W
  {0x00,0x42,0x42,0x24,0x18,0x24,0x42,0x42}, // X
  {0x00,0x44,0x44,0x28,0x10,0x10,0x10,0x10}, // Y
  {0x00,0x7c,0x04,0x08,0x7c,0x20,0x40,0xfe}, // Z
  // (the font does not contain any lower case letters. you can add your own.)
};    // {}, // 

// This sketch draw marquee text on your LED matrix using the hardware SPI driver Library by Bartosz Bielawski.
// Example written 16.06.2017 by Marko Oette, www.oette.info 

// Define the ChipSelect pin for the led matrix (Dont use the SS or MISO pin of your Arduino!)
// Other pins are arduino specific SPI pins (MOSI=DIN of the LEDMatrix and CLK) see https://www.arduino.cc/en/Reference/SPI

// Define LED Matrix dimensions (0-n) - eg: 32x8 = 31x7
const int LEDMATRIX_WIDTH = 31;  
const int LEDMATRIX_HEIGHT = 7;
const int LEDMATRIX_SEGMENTS = 2;

void setup(void) {
  // The LEDMatrixDriver class instance
  LEDMatrixDriver(LEDMATRIX_SEGMENTS);
  // init the display
  setEnabled(true);
  setIntensity(0);   // 0 = low, 10 = high
}

int x=0, y=0;   // start top left

// Marquee speed
const int ANIM_DELAY = 150;

// Marquee text 
char *text = "** LED MATRIX DEMO! ** (1234567890) ++ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ++ <$%/=?'.@,> --";
int len;


void loop(void) 
{
 len = strlen(text);
 // Draw the text to the current position
 drawString(text, len, x, 0);
   // In case you wonder why we don't have to call lmd.clear() in every loop: The font has a opaque (black) background...
 
 // Toggle display of the new framebuffer
 display();

 // Wait to let the human read the display
 HAL_Delay(ANIM_DELAY);

 // Advance to next coordinate
 if(--x < len * -8)
   x = LEDMATRIX_WIDTH;
}

void LEDMatrixDriver(uint8_t Nx)
{
  N=Nx;
  selfAllocated=(frameBuffer == 0 /* nullptr */);
  if (selfAllocated)
  frameBuffer = malloc(sizeof(N*8*Nx));
  // initally clear the buffer as the memory will not be initialized on reset (old content will be in memory yet)
  memset(frameBuffer, 0, 8*N*Nx);

  setEnabled(false);
  setIntensity(0);
  _sendCommand(TEST); //no test
  _sendCommand(DECODE); //no decode
  _sendCommand(SCAN_LIMIT | 7); //all lines
}

void setPixel(uint16_t x, uint16_t y, bool enabled)
{
  if (y >= 8)
  return;
  if (x >= (8*N))
  return;
  uint16_t B = x >> 3; //byte
  uint16_t b = 7 - (x & 7); //bit
  uint8_t* v = &(frameBuffer[y*N + B]);
  if (enabled)
  *v |= (1<<b);
  else
  *v &= ~(1<<b);
}

void setColumn(uint16_t x, uint8_t value)
{
  if (x >= (8*N))
  return;
  for (uint8_t y = 0; y < 8; ++y)
  {
    setPixel(x, y, value & 1);
    value >>= 1;
  }
}

void setEnabled(bool enabled)
{
  _sendCommand(MATRIX_ON | (enabled ? 1: 0));
}

void setIntensity(uint8_t level)
{
  _sendCommand(INTENSITY | level);
}

void _sendCommand(uint16_t command)
{
  soft_spi_begin();
  soft_spi_transfer(command);
  //pin_write(CS_GPIO_Port, CS_Pin, 0);
  for (uint8_t i = 0; i < N; ++i)
  {
    soft_spi_transfer(command>>8);
    soft_spi_transfer(command&0x00ff);
  }
  //pin_write(CS_GPIO_Port, CS_Pin, 1);
  pin_pulse_low_hi(CS_GPIO_Port, CS_Pin, SPI_CLOCK_DIV128);
  soft_spi_end();
}

void _displayRow(uint8_t row)
{
  soft_spi_begin();
  //pin_write(CS_GPIO_Port, CS_Pin, 0);
  for (uint16_t d = 0; d < N; d++)
  {
    uint16_t cmd = ((row + 1) << 8) | frameBuffer[d + row*N];
    soft_spi_transfer(cmd>>8);
    soft_spi_transfer(cmd&0x00ff);
  }
  //pin_write(CS_GPIO_Port, CS_Pin, 1);
  pin_pulse_low_hi(CS_GPIO_Port, CS_Pin, SPI_CLOCK_DIV128);
  soft_spi_end();
}

void display(void)
{
  for (uint8_t y = 0; y < 8; y++)
  {
    _displayRow(y);
  }
}

/**
 * This function draws a string of the given length to the given position.
 */
void drawString(char* text, int len, int x, int y)
{
  for(int idx = 0; idx < len; idx ++)
  {
    int c = text[idx] - 32;

    // stop if char is outside visible area
    if(x + idx * 8  > LEDMATRIX_WIDTH)
      return;

    // only draw if char is visible
    if(8 + x + idx * 8 > 0)
      drawSprite(font[c], x + idx * 8, y, 8, 8);
  }
}

/**
 * This draws a sprite to the given position using the width and height supplied (usually 8x8)
 */
void drawSprite(uint8_t* sprite, int x, int y, int width, int height)
{
  // The mask is used to get the column bit from the sprite row
  uint8_t mask = 0b10000000;
  
  for(int iy = 0; iy < height; iy++)
  {
    for(int ix = 0; ix < width; ix++)
    {
      setPixel(x + ix, y + iy, (bool)(sprite[iy] & mask));

      // shift the mask by one pixel to the right
      mask = mask >> 1;
    }

    // reset column mask
    mask = 0b10000000;
  }
}

void scroll(uint8_t direction)
{
  int cnt = 0;
  uint8_t* buf = NULL;
  switch(direction)
  {
   case scrollUp:
    cnt = 7*(N); // moving 7 rows of N segments
    memmove(frameBuffer, frameBuffer + N, cnt);
    memset(frameBuffer+cnt, 0, N); // Clear last row
   break;
   case scrollDown:
    cnt = 7*N; // moving 7 rows of N segments
    memmove(frameBuffer+N, frameBuffer, cnt);
    memset(frameBuffer, 0, N); // Clear first row
   break;
   case scrollRight:
    // Scrolling right needs to be done by bit shifting every uint8_t in the frame buffer
    // Bits that overlap need to be carried to the next cell in a row
    for(int i = 8*N; i >= 0; i--)
    {
      uint8_t n = frameBuffer[i] & 1;
      frameBuffer[i] >>= 1;
      if((i+1)%N > 0)
      frameBuffer[i+1] |= n<<7;
    }
   break;
   case scrollLeft:
    // Scrolling left needs to be done by bit shifting every uint8_t in the frame buffer
    // Bits that overlap need to be carried to the prev cell in a row
    for(int i = 0; i < 8*N; i++)
    {
      uint8_t n = frameBuffer[i] & 0b10000000;
      frameBuffer[i] <<= 1;
      if(i%N > 0)
      frameBuffer[i-1] |= n>>7;
    }
   break;
  }
}
